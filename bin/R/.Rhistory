color_breaks <- c(-5, seq(min(heatmap_matrix[heatmap_matrix > -5], na.rm = TRUE), max(heatmap_matrix, na.rm = TRUE), length.out = 100))
color_palette <- c("grey", colorRampPalette(c("blue", "red"))(99))
pdf(paste0("../../results/pop_freq/", gene, "_population_heatmap.pdf"), width = 20, height = 10)
pheatmap(heatmap_matrix, cluster_rows = FALSE, cluster_cols = FALSE,
main = paste("Heatmap of log10 Allele Frequencies for", gene),
fontsize = 25,
fontsize_row = 20, fontsize_col = 18,
breaks = color_breaks, color = color_palette,
labels_col = ifelse(apply(heatmap_matrix, 2, max, na.rm = TRUE) > -1, colnames(heatmap_matrix), ""))
dev.off()
# Append all gene data
all_gene_data <- rbind(all_gene_data, gene_data_melted)
}
# Load data
data <- read.csv("../../data/gnomad_region_data.csv")
# Ensure results directory exists
if (!dir.exists("../../results/pop_freq")) {
dir.create("../../results/pop_freq")
}
# Mapping of population abbreviations to full names
population_map <- c(
afr = "African/African American",
ami = "Amish",
amr = "Latino/Admixed American",
asj = "Ashkenazi Jewish",
eas = "East Asian",
fin = "Finnish",
nfe = "Non-Finnish European",
mid = "Middle Eastern",
sas = "South Asian",
remaining = "Other (population not assigned)"
)
# List of population prefixes matching column names
populations <- names(population_map)
existing_populations <- populations[sapply(paste0(populations, "_af"), function(col) col %in% colnames(data))]
# Compute log10(frequency) safely
for (pop in existing_populations) {
af_col <- paste0(pop, "_af")
data[[paste0("log10_", pop, "_af")]] <- log10(ifelse(is.na(data[[af_col]]), 1e-5, data[[af_col]]) + 1e-5)
}
unique_genes <- unique(data$gene_name)
all_gene_data <- data.frame()
for (gene in unique_genes ) {
print(paste("Processing gene:", gene))
gene_data <- subset(data, gene_name == gene)
gene_data <- subset(gene_data, grepl("^n\\.\\d+[ACGT]>[ACGT]$", gene_data$variation_consequence))
if (nrow(gene_data) == 0) next
gene_data_melted <- melt(gene_data, id.vars = c("variation_id", "variation_consequence"),
measure.vars = paste0("log10_", existing_populations, "_af"),
variable.name = "Population", value.name = "Log10_AF")
gene_data_melted$Population <- population_map[gsub("log10_|_af", "", gene_data_melted$Population)]
# Cumulative Distribution Plot
#cdf_plot <- ggplot(gene_data_melted, aes(x = Log10_AF, color = Population)) +
#  stat_ecdf(size = 1.2) +
#  labs(title = paste("Cumulative Distribution of log10 Allele Frequencies for", gene),
#       x = "log10(Allele Frequency)", y = "Cumulative Proportion") +
#  theme_minimal(base_size = 22) +
#  theme(legend.text = element_text(size = 20), legend.title = element_text(size = 22),
#        plot.title = element_text(size = 24, face = "bold"))
#ggsave(filename = paste0("../../results/pop_freq/", gene, "_population_cdf.pdf"), plot = cdf_plot, width = 20, height = 15)
# Heatmap Preparation
heatmap_data <- reshape2::dcast(gene_data_melted, Population ~ variation_consequence, value.var = "Log10_AF")
rownames(heatmap_data) <- heatmap_data$Population
heatmap_data$Population <- NULL
heatmap_matrix <- as.matrix(heatmap_data)
heatmap_matrix[is.na(heatmap_matrix)] <- -5  # Assign low log value for missing variants
color_breaks <- c(-5, seq(min(heatmap_matrix[heatmap_matrix > -5], na.rm = TRUE), max(heatmap_matrix, na.rm = TRUE), length.out = 100))
color_palette <- c("grey", colorRampPalette(c("blue", "red"))(99))
pdf(paste0("../../results/pop_freq/", gene, "_population_heatmap.pdf"), width = 25, height = 10)
pheatmap(heatmap_matrix, cluster_rows = FALSE, cluster_cols = FALSE,
main = paste("Heatmap of log10 Allele Frequencies for", gene),
fontsize = 25,
fontsize_row = 20, fontsize_col = 18,
breaks = color_breaks, color = color_palette,
labels_col = ifelse(apply(heatmap_matrix, 2, max, na.rm = TRUE) > -1, colnames(heatmap_matrix), ""))
dev.off()
# Append all gene data
all_gene_data <- rbind(all_gene_data, gene_data_melted)
}
# Generate heatmap
pheatmap(scaled_data,
cluster_rows = TRUE,
cluster_cols = TRUE,
show_rownames = FALSE,
main = "Variant Quality Metrics Heatmap")
library(tidyverse)
library(pheatmap)
# Load data
data <- read.csv("../../data/variant_qual_metrics.csv")
# Function to check if a variant is a SNP
is_snp <- function(variation_id) {
parts <- unlist(strsplit(variation_id, "-"))
if (length(parts) < 4) return(FALSE)  # Ensure the format is correct
ref <- parts[length(parts) - 1]  # Second to last part
alt <- parts[length(parts)]  # Last part
return(nchar(ref) == 1 & nchar(alt) == 1)  # SNPs have single character ref and alt
}
# Filter for SNPs only
data_filtered <- data %>%
filter(sapply(Variation_ID, is_snp)) %>%
select(GeneName, Variation_ID, SiteQuality, AS_MQ, AS_FS, AS_MQRankSum, AS_pab_max,
AS_ReadPosRankSum, AS_SOR, AS_VarDP)
# Normalize data for heatmap visualization
scaled_data <- data_filtered %>%
select(-GeneName, -Variation_ID) %>%
scale() %>%
as.data.frame()
rm(list = ls())
library(tidyverse)
library(pheatmap)
# Load data
data <- read.csv("../../data/variant_qual_metrics.csv")
# Function to check if a variant is a SNP
is_snp <- function(variation_id) {
parts <- unlist(strsplit(variation_id, "-"))
if (length(parts) < 4) return(FALSE)  # Ensure the format is correct
ref <- parts[length(parts) - 1]  # Second to last part
alt <- parts[length(parts)]  # Last part
return(nchar(ref) == 1 & nchar(alt) == 1)  # SNPs have single character ref and alt
}
# Filter for SNPs only
data_filtered <- data %>%
filter(sapply(Variation_ID, is_snp)) %>%
select(GeneName, Variation_ID, SiteQuality, AS_MQ, AS_FS, AS_MQRankSum, AS_pab_max,
AS_ReadPosRankSum, AS_SOR, AS_VarDP)
# Normalize data for heatmap visualization
scaled_data <- data_filtered %>%
select(-GeneName, -Variation_ID) %>%
scale() %>%
as.data.frame()
View(data)
library(tidyverse)
library(pheatmap)
# Load data
data <- read.csv("../../data/variant_qual_metrics.csv")
# Function to check if a variant is a SNP
is_snp <- function(variation_id) {
parts <- unlist(strsplit(variation_id, "-"))
if (length(parts) < 4) return(FALSE)  # Ensure the format is correct
ref <- parts[length(parts) - 1]  # Second to last part
alt <- parts[length(parts)]  # Last part
return(nchar(ref) == 1 & nchar(alt) == 1)  # SNPs have single character ref and alt
}
# Filter for SNPs only
data_filtered <- data %>%
filter(sapply(Variation_ID, is_snp)) %>%
select(GeneName, Variation_ID, SiteQuality, AS_MQ, AS_FS, AS_MQRankSum, AS_pab_max,
AS_ReadPosRankSum, AS_SOR, AS_VarDP)
# Replace NA values with 0 before scaling
scaled_data <- data_filtered %>%
select(-GeneName, -Variation_ID) %>%
mutate(across(everything(), ~replace_na(as.numeric(.), 0))) %>%
scale() %>%
as.data.frame()
# Add row names for identification
rownames(scaled_data) <- data_filtered$Variation_ID
# Generate heatmap
pheatmap(scaled_data,
cluster_rows = TRUE,
cluster_cols = TRUE,
show_rownames = FALSE,
main = "Variant Quality Metrics Heatmap")
library(tidyverse)
library(pheatmap)
# Load data
data <- read.csv("../../data/variant_qual_metrics.csv")
# Function to check if a variant is a SNP
is_snp <- function(variation_id) {
parts <- unlist(strsplit(variation_id, "-"))
if (length(parts) < 4) return(FALSE)  # Ensure the format is correct
ref <- parts[length(parts) - 1]  # Second to last part
alt <- parts[length(parts)]  # Last part
return(nchar(ref) == 1 & nchar(alt) == 1)  # SNPs have single character ref and alt
}
# Filter for SNPs only
data_filtered <- data %>%
filter(sapply(Variation_ID, is_snp)) %>%
select(GeneName, Variation_ID, SiteQuality, AS_MQ, AS_FS, AS_MQRankSum, AS_pab_max,
AS_ReadPosRankSum, AS_SOR, AS_VarDP)
# Replace NA values with 0 and scale each metric individually
scaled_data <- data_filtered %>%
select(-Variation_ID) %>%
group_by(GeneName) %>%
mutate(across(-GeneName, ~replace_na(as.numeric(.), 0))) %>%
mutate(across(-GeneName, scale)) %>%
pivot_longer(-GeneName, names_to = "Metric", values_to = "Value") %>%
pivot_wider(names_from = GeneName, values_from = Value)
library(tidyverse)
library(pheatmap)
# Load data
data <- read.csv("../../data/variant_qual_metrics.csv")
# Function to check if a variant is a SNP
is_snp <- function(variation_id) {
parts <- unlist(strsplit(variation_id, "-"))
if (length(parts) < 4) return(FALSE)  # Ensure the format is correct
ref <- parts[length(parts) - 1]  # Second to last part
alt <- parts[length(parts)]  # Last part
return(nchar(ref) == 1 & nchar(alt) == 1)  # SNPs have single character ref and alt
}
# Filter for SNPs only
data_filtered <- data %>%
filter(sapply(Variation_ID, is_snp)) %>%
select(GeneName, Variation_ID, SiteQuality, AS_MQ, AS_FS, AS_MQRankSum, AS_pab_max,
AS_ReadPosRankSum, AS_SOR, AS_VarDP)
# Replace NA values and scale each metric individually
scaled_data <- data_filtered %>%
mutate(across(-c(GeneName, Variation_ID), ~replace_na(as.numeric(.), 0))) %>%
mutate(across(-c(GeneName, Variation_ID), scale)) %>%
select(-Variation_ID) %>%
pivot_longer(-GeneName, names_to = "Metric", values_to = "Value") %>%
pivot_wider(names_from = GeneName, values_from = Value)
# Set row names for metrics
rownames(scaled_data) <- scaled_data$Metric
scaled_data <- scaled_data %>% select(-Metric)
# Generate heatmap with metrics on y-axis and genes on x-axis
pheatmap(as.matrix(scaled_data),
cluster_rows = TRUE,
cluster_cols = TRUE,
show_colnames = TRUE,
show_rownames = TRUE,
main = "Quality Metrics by Gene")
library(tidyverse)
library(pheatmap)
# Load data
data <- read.csv("../../data/variant_qual_metrics.csv")
# Function to check if a variant is a SNP
is_snp <- function(variation_id) {
parts <- unlist(strsplit(variation_id, "-"))
if (length(parts) < 4) return(FALSE)  # Ensure the format is correct
ref <- parts[length(parts) - 1]  # Second to last part
alt <- parts[length(parts)]  # Last part
return(nchar(ref) == 1 & nchar(alt) == 1)  # SNPs have single character ref and alt
}
# Filter for SNPs only
data_filtered <- data %>%
filter(sapply(Variation_ID, is_snp)) %>%
select(GeneName, Variation_ID, SiteQuality, AS_MQ, AS_FS, AS_MQRankSum, AS_pab_max,
AS_ReadPosRankSum, AS_SOR, AS_VarDP)
# Replace NA values, safely coerce to numeric, and handle duplicates
scaled_data <- data_filtered %>%
mutate(across(-c(GeneName, Variation_ID), ~replace_na(as.numeric(.), 0))) %>%
select(-Variation_ID) %>%
pivot_longer(-GeneName, names_to = "Metric", values_to = "Value") %>%
group_by(Metric, GeneName) %>%
summarize(Value = mean(Value, na.rm = TRUE), .groups = 'drop') %>%
pivot_wider(names_from = GeneName, values_from = Value, values_fill = 0)
# Set row names for metrics
rownames(scaled_data) <- scaled_data$Metric
scaled_data <- scaled_data %>% select(-Metric)
# Generate heatmap with metrics on y-axis and genes on x-axis
pheatmap(as.matrix(scaled_data),
cluster_rows = TRUE,
cluster_cols = TRUE,
show_colnames = TRUE,
show_rownames = TRUE,
main = "Quality Metrics by Gene")
library(tidyverse)
library(pheatmap)
# Load data
data <- read.csv("../../data/variant_qual_metrics.csv")
# Function to check if a variant is a SNP
is_snp <- function(variation_id) {
parts <- unlist(strsplit(variation_id, "-"))
if (length(parts) < 4) return(FALSE)  # Ensure the format is correct
ref <- parts[length(parts) - 1]  # Second to last part
alt <- parts[length(parts)]  # Last part
return(nchar(ref) == 1 & nchar(alt) == 1)  # SNPs have single character ref and alt
}
# Filter for SNPs only
data_filtered <- data %>%
filter(sapply(Variation_ID, is_snp)) %>%
select(GeneName, Variation_ID, SiteQuality, AS_MQ, AS_FS, AS_MQRankSum, AS_pab_max,
AS_ReadPosRankSum, AS_SOR, AS_VarDP)
# Replace NA values, safely coerce to numeric, and handle duplicates
clean_data <- data_filtered %>%
mutate(across(-c(GeneName, Variation_ID), ~replace_na(as.numeric(.), 0))) %>%
select(-Variation_ID) %>%
pivot_longer(-GeneName, names_to = "Metric", values_to = "Value") %>%
group_by(Metric, GeneName) %>%
summarize(Value = mean(Value, na.rm = TRUE), .groups = 'drop')
# Generate a separate heatmap for each metric
unique_metrics <- unique(clean_data$Metric)
for (metric in unique_metrics) {
metric_data <- clean_data %>%
filter(Metric == metric) %>%
select(-Metric) %>%
pivot_wider(names_from = GeneName, values_from = Value, values_fill = 0)
# Set row name to the metric name
rownames(metric_data) <- c(metric)
# Generate heatmap
pheatmap(as.matrix(metric_data),
cluster_rows = FALSE,
cluster_cols = TRUE,
show_colnames = TRUE,
show_rownames = TRUE,
main = paste("Heatmap for", metric))
}
View(data)
library(tidyverse)
library(pheatmap)
# Load data
data <- read.csv("../../data/variant_qual_metrics.csv")
# Function to check if a variant is a SNP
is_snp <- function(variation_id) {
parts <- unlist(strsplit(variation_id, "-"))
if (length(parts) < 4) return(FALSE)  # Ensure the format is correct
ref <- parts[length(parts) - 1]  # Second to last part
alt <- parts[length(parts)]  # Last part
return(nchar(ref) == 1 & nchar(alt) == 1)  # SNPs have single character ref and alt
}
# Filter for SNPs only
data_filtered <- data %>%
filter(sapply(Variation_ID, is_snp)) %>%
select(GeneName, Variation_ID, SiteQuality, AS_MQ, AS_FS, AS_MQRankSum, AS_pab_max,
AS_ReadPosRankSum, AS_SOR, AS_VarDP)
# Apply log10 transformation to specific metrics
data_filtered <- data_filtered %>%
mutate(SiteQuality = log10(SiteQuality + 1),  # Avoid log10(0)
AS_VarDP = log10(AS_VarDP + 1))
# Replace NA values and handle duplicates
clean_data <- data_filtered %>%
mutate(across(-c(GeneName, Variation_ID), ~replace_na(as.numeric(.), NA))) %>%
select(-Variation_ID) %>%
pivot_longer(-GeneName, names_to = "Metric", values_to = "Value") %>%
group_by(Metric, GeneName) %>%
summarize(Value = mean(Value, na.rm = TRUE), .groups = 'drop')
# Quality thresholds
quality_thresholds <- list(
SiteQuality = c(high = 30, low = 20),
AS_FS = c(high = 20, low = 0),
AS_MQ = c(high = 55, low = 40),
AS_MQRankSum = c(high = 2, low = -2),
AS_pab_max = c(high = 0.001, low = 0),
AS_ReadPosRankSum = c(high = 2, low = -2),
AS_SOR = c(high = 3, low = 4),
AS_VarDP = c(high = 10, low = 0)
)
# Generate one heatmap per gene with all metrics
unique_genes <- unique(clean_data$GeneName)
for (gene in unique_genes) {
gene_data <- clean_data %>%
filter(GeneName == gene) %>%
select(-GeneName) %>%
pivot_wider(names_from = Metric, values_from = Value, values_fill = NA)
# Set row names to metrics
rownames(gene_data) <- gene_data$Metric
gene_data <- gene_data %>% select(-Metric)
# Generate heatmap with NA values in grey
pheatmap(as.matrix(gene_data),
cluster_rows = FALSE,
cluster_cols = TRUE,
show_colnames = TRUE,
show_rownames = TRUE,
main = paste("Heatmap for", gene),
na_col = "grey")
}
library(tidyverse)
library(pheatmap)
# Load data
data <- read.csv("../../data/variant_qual_metrics.csv")
# Function to check if a variant is a SNP
is_snp <- function(variation_id) {
parts <- unlist(strsplit(variation_id, "-"))
if (length(parts) < 4) return(FALSE)  # Ensure the format is correct
ref <- parts[length(parts) - 1]  # Second to last part
alt <- parts[length(parts)]  # Last part
return(nchar(ref) == 1 & nchar(alt) == 1)  # SNPs have single character ref and alt
}
# Filter for SNPs only
data_filtered <- data %>%
filter(sapply(Variation_ID, is_snp)) %>%
select(GeneName, Variation_ID, SiteQuality, AS_MQ, AS_FS, AS_MQRankSum, AS_pab_max,
AS_ReadPosRankSum, AS_SOR, AS_VarDP)
# Apply log10 transformation to specific metrics
data_filtered <- data_filtered %>%
mutate(SiteQuality = log10(SiteQuality + 1),  # Avoid log10(0)
AS_VarDP = log10(AS_VarDP + 1))
# Replace NA values and handle duplicates
clean_data <- data_filtered %>%
mutate(across(-c(GeneName, Variation_ID), ~replace_na(as.numeric(.), NA))) %>%
select(-Variation_ID) %>%
pivot_longer(-GeneName, names_to = "Metric", values_to = "Value") %>%
group_by(Metric, GeneName) %>%
summarize(Value = mean(Value, na.rm = TRUE), .groups = 'drop')
# Quality thresholds
quality_thresholds <- list(
SiteQuality = c(high = 30, low = 20),
AS_FS = c(high = 20, low = 0),
AS_MQ = c(high = 55, low = 40),
AS_MQRankSum = c(high = 2, low = -2),
AS_pab_max = c(high = 0.001, low = 0),
AS_ReadPosRankSum = c(high = 2, low = -2),
AS_SOR = c(high = 3, low = 4),
AS_VarDP = c(high = 10, low = 0)
)
# Generate one heatmap per gene with all metrics
unique_genes <- unique(clean_data$GeneName)
for (gene in unique_genes) {
gene_data <- clean_data %>%
filter(GeneName == gene) %>%
select(-GeneName) %>%
pivot_wider(names_from = GeneName, values_from = Value, values_fill = NA)
# Set row names to metrics
rownames(gene_data) <- gene_data$Metric
gene_data <- gene_data %>% select(-Metric)
# Generate heatmap with NA values in grey
pheatmap(as.matrix(gene_data),
cluster_rows = FALSE,
cluster_cols = TRUE,
show_colnames = TRUE,
show_rownames = TRUE,
main = paste("Heatmap for", gene),
na_col = "grey")
}
library(tidyverse)
library(pheatmap)
# Load data
data <- read.csv("../../data/variant_qual_metrics.csv")
# Function to check if a variant is a SNP
is_snp <- function(variation_id) {
parts <- unlist(strsplit(variation_id, "-"))
if (length(parts) < 4) return(FALSE)  # Ensure the format is correct
ref <- parts[length(parts) - 1]  # Second to last part
alt <- parts[length(parts)]  # Last part
return(nchar(ref) == 1 & nchar(alt) == 1)  # SNPs have single character ref and alt
}
# Filter for SNPs only
data_filtered <- data %>%
filter(sapply(Variation_ID, is_snp)) %>%
select(GeneName, Variation_ID, SiteQuality, AS_MQ, AS_FS, AS_MQRankSum, AS_pab_max,
AS_ReadPosRankSum, AS_SOR, AS_VarDP)
# Apply log10 transformation to specific metrics
data_filtered <- data_filtered %>%
mutate(SiteQuality = log10(SiteQuality + 1),  # Avoid log10(0)
AS_VarDP = log10(AS_VarDP + 1))
# Replace NA values and handle duplicates
clean_data <- data_filtered %>%
mutate(across(-c(GeneName, Variation_ID), ~replace_na(as.numeric(.), NA))) %>%
select(-Variation_ID) %>%
pivot_longer(-GeneName, names_to = "Metric", values_to = "Value") %>%
group_by(Metric, GeneName) %>%
summarize(Value = mean(Value, na.rm = TRUE), .groups = 'drop')
# Quality thresholds
quality_thresholds <- list(
SiteQuality = c(high = 30, low = 20),
AS_FS = c(high = 20, low = 0),
AS_MQ = c(high = 55, low = 40),
AS_MQRankSum = c(high = 2, low = -2),
AS_pab_max = c(high = 0.001, low = 0),
AS_ReadPosRankSum = c(high = 2, low = -2),
AS_SOR = c(high = 3, low = 4),
AS_VarDP = c(high = 10, low = 0)
)
# Generate one heatmap per gene with all metrics
unique_genes <- unique(clean_data$GeneName)
for (gene in unique_genes) {
gene_data <- clean_data %>%
filter(GeneName == gene) %>%
select(-GeneName) %>%
pivot_wider(names_from = Metric, values_from = Value, values_fill = NA)
# Set row names to metrics
rownames(gene_data) <- gene_data$Metric
gene_data <- gene_data %>% select(-Metric)
# Generate heatmap with NA values in grey
pheatmap(as.matrix(gene_data),
cluster_rows = FALSE,
cluster_cols = TRUE,
show_colnames = TRUE,
show_rownames = TRUE,
main = paste("Heatmap for", gene),
na_col = "grey")
}
View(clean_data)
# Load necessary libraries
library(ggplot2)
library(reshape2)
library(dplyr)
library(viridis)
library(tidyr)
# Read the CSV file
data <- read.csv("../../data/variant_qual_metrics.csv")
# Subset relevant columns for the heatmap
metrics <- c("SiteQuality", "AS_FS", "AS_MQRankSum", "AS_pab_max", "AS_ReadPosRankSum", "AS_SOR", "AS_VarDP")
# Log transform 'SiteQuality' and 'AS_VarDP' columns to make them comparable in scale
data$Log_SiteQuality <- log1p(data$SiteQuality)  # log(x+1) transformation for zero and positive values
data$Log_AS_VarDP <- log1p(data$AS_VarDP)
# Reshape the data into a format suitable for the heatmap
data_melted <- data %>%
select(GeneName, Variation_ID, one_of(metrics), Log_SiteQuality, Log_AS_VarDP) %>%
melt(id.vars = c("GeneName", "Variation_ID"), variable.name = "Metric", value.name = "Value")
# Select the metrics to plot
metrics_to_plot <- c("SiteQuality", "AS_FS", "AS_MQRankSum", "AS_pab_max", "AS_ReadPosRankSum", "AS_SOR", "Log_SiteQuality", "Log_AS_VarDP")
# Subset the melted data for the metrics we want to plot
data_melted <- data_melted %>%
filter(Metric %in% metrics_to_plot)
# Create the heatmap using ggplot, handling N/A as grey
ggplot(data_melted, aes(x = Variation_ID, y = Metric, fill = ifelse(is.na(Value), "grey", as.character(Value)))) +
geom_tile() +
facet_wrap(~ GeneName, scales = "free_y") +  # Create separate heatmaps for each gene
scale_fill_manual(values = c("grey" = "grey", "low" = "cornflowerblue", "mid" = "white", "high" = "firebrick1")) +  # Add custom color scale
theme_minimal() +
labs(title = "Heatmap of Variant Metrics by Gene", x = "Variation ID", y = "Metric") +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  # Rotate x-axis labels for better readability
scale_y_discrete(limits = rev(levels(data_melted$Metric)))  # Reverse y-axis to have SiteQuality and AS_VarDP on top
# Create summary distribution plots (e.g., boxplots) for each metric
# The metrics to plot are listed above (metrics_to_plot)
ggplot(data_melted, aes(x = Metric, y = Value, fill = Metric)) +
geom_boxplot(outlier.size = 1) +  # Use boxplots for distribution
facet_wrap(~ Metric, scales = "free_y") +  # Separate plots for each metric
theme_minimal() +
labs(title = "Distribution of Metrics for Variations", x = "Metric", y = "Value") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
